Question 1 - May 4, 2012
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
After I updated to Xcode 4.2, I can no longer release anything. When I start typing "release" it suggest "release" but with a red line across.
If I write it anyway it shows an error and displays these two messages:
'release' is unavailable: not available in automatic reference counting mode Automatic Reference Counting forbids explicit message send of 'release'
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
You need to turn off Automatic Reference Counting. You do this by clicking on your project in the navigator (the top item in the finder-like thing on the left), then click on your 
target, select "Build Settings" and turn off the option "Objective-C Automatic Reference Counting" (you can use the search field on the upper right to search it).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Question 2 - May 4, 2012
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Adding Custom Fonts iOS 4
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
This tutorial will show you how to add your own custom fonts into an app for devices using iOS 4 and above.
While working on a new app I was wondering how if there was anyway I could use the same font I had used for my logo and buttons within UITextViews and wherever else I wanted to a 
display custom text
  1) Add the .TTF or .OTF font file/s you wish to use as a resource
  2) Open your info.plist and create a new key called UIAppFonts, set the key to be an array type.
  3) For each font you want to use in your app, add it as a new object in the array with its full name and extension and save the info.plist when finished
  4) Now in your code you can simply call
         1.1 Default UIFont Example [UIFont fontWithName:@"Insert font name here" size:18]
     to get the custom font to use with your UILabels and UITextView. Or if using Cocos2d you can call
         1.2 Cocos2d Label Example CCLabelTTF *header = [CCLabelTTF labelWithString:@"Hello World" fontName:@"Insert font name here" fontSize:22];
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Question 3 - May 5, 2012
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Debugger GDB vs. LLDB
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
It depends on your compiler. 
I would recommend using the lldb debugger with the "Apple LLVM compiler 3.0", and gdb for GCC flavors (including "LLVM GCC 4.2").
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Question 4 - May 17, 2012
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
How to build test framework with GHUnit
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Ref Doc: wiki/how-to-build-test-with-ghunit.doc
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Question 5 - June 02, 2012
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Enum defining forms in Objective-C
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
typedef enum {
	. . .
} Name;

and

enum {
	. . .
};
typedef NSUInteger Name;
? If functionality is the same, what is the second form good for? Isn't it unnecessarily messy?

The former defines a type name to refer to an enum. This is the way most enums are named in C.
The later is a bit different though, and it's prevalent in the Cocoa frameworks. There's two reasons to use the later. The first is if your enum defines a bitfield, and you'd want
it here because when you're providing a 'Name' value you'll be providing a combination of the enum values. In other words, if you say something like:
	[self doSomethingWithBitfield:(Enum1 | Enum2)]
you're not passing a value of Name but rather an integer that's a combination of the two.
However, Cocoa frameworks use this idiom even for non-bitfield values, for a very good reason: API stability. According to the C standard, the underlying integral type of an enum
is requires to be able to contain all values in the enum, but is otherwise chosen by the compiler. This means that adding a enum value could change the integral typeof the enum(
e.g. adding -1 can make it signed, adding 6 billion can make it to a long long, etc.) This is a bad thing from an API stability standpoint, because the type encoding of methods 
which take values of this enum could change unexpectedly and potentially break existing code and binaries. In order to prevent this, the Cocoa frameworks generally define the type
as being an NSUInteger (or NSInteger if they need negative numbers), so the API and type encodings stay stable.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Question 6 - June 04, 2012
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
How to encapsulate struct value into NSValue?
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Encapsulate:
	CGPoint pt = CGPointMake(1, 2);
	NSValue *boxedPt = [NSValue valueWithBytes:&pt objCType:@encode(CGPoint)];
Decapsulate:
	CGPoint pt2;
	[boxedPt getValue:&pt2];
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Question 7 - June 05, 2012
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
How to Compare 2 NSStrings?
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
NSString *str1 = @"123";
[str1 isEqualToString:@"123"]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Question 8 - June 11, 2012
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
How to check condition?
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
(1) Check with exception:
	A. [NSException raise:NSInternalInconsistencyException format:@"Mumblefart can't be something or othered"];
	   return nil;	// Can't actually get here. Awkward code â€¦ But it's necessary, otherwise the compiler doesn't recognize that this represents a throw and sometimes you wind
			   up with awkward: "Control may reach end of non-void function" case.
	B. @throw [NSException exceptionWithName:NSInvalidArgumentException reason:@"pageIndex is out of range" userInfo:nil];
(2) Use the NSAssert() and NSParameterAssert() macros. They do the testing without a visible if () block, and they become no-ops when you define NS_BLOCK_ASSERTIONS in your release
    builds.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~